Summary: This work aggregates noisy/inconsistent pairwise preferences into a rating for each item, as well as actively selecting the pairs to query. The technique used for aggregation is the Bradley-Terry model with computational saving techniques. The pairs are queried with Expected Information Gain (from the Bradley-Terry model) and either choosing the most informative pairs or choosing a batch of pairs corresponding to a MST built on the graph with edges based on the most informative pairs.  Questions: Something that I didn’t quite understand is that this work claimed to run the preferences in batches, however, it doesn’t appear that they are run in batches for the first standard trial number. Can the authors please clarify this?  The runtime for small problems (n=10-20) show that the algorithm runs relatively slowly and quadratically. How does this scale to the large real-world datasets? Why weren’t runtime experiments run for the real-world datasets?  Quality: The techniques in this work seem to be relatively principled and fit into the related work well. The experiments show that this is an effective technique compared to the related work, at least for two datasets, IQA and VQA. Generally, in the experiments, the technique achieves the same results with half the number of comparisons.  Clarity: This paper lays out concepts in an orderly way and is clear to read. One minor note is that the “Notation” section includes more than just notation, but modeling assumptions, so it is more than just notation. Also, I think the indentation of Algorithm 1 is off, the “end for” should come earlier.  Originality: This work seems like a different take on a well-established problem. I’m not familiar enough with the preference aggregation literature to determine how similar this is to other work.  Significance: I have some concerns with the runtime and efficiency of the method proposed in this work, however, it seems principled and has good empirical accuracies.   After rebuttal: Thank you for the runtime experiments. I now see that the runtime is small compared to the annotation time.