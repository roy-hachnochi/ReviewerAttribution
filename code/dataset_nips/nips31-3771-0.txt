In this submission, the authors describe the design, implementation and performance of Edward2, a low-level probabilistic programming language that seamlessly integrates tensorflow, in particular, tensorflow distribution. The key concept of Edward2 is the random variable, which should be understand as general python functions possibly with random choices in the context of Edward2. Also, continuing the design decision of its first version, Edward2 implements the principle of exposing inference to the users while providing them with enough components and combinators so as to make building custom-inference routines easy. This is different from the principle behind other high-level probabilistic programming systems, which is to hide or automate inference from their users. The submission explains a wide range of benefits of following this principle of exposing inference, such as huge boost in the scalability of inference engines and support for non-standard inference tasks.  I support the acceptance of the submission. This submission is about a system, called Edward2. So, it does not have new mathematical theorems or many new ideas. However, the system built is very impressive, and I think that NIPS audience would be very interested to hear about it. The paper gives a good overview on what goes on in Edward2.  The explanation on tracing in Edward2 reminds me a lot of poutine in pyro. I think that pyro also heavily rely on tracing, and includes a wide range of library functions for manipulating it. According to my understanding, the implementation of these functions in pyro also uses python context (i.e. a form of aspect-oriented programming) so as to define a new way of running a program or extracting information from program execution. It would help me improve my understanding of Edward2 greatly if there is more thorough comparison between pyro and Edward2. Also, I want to know how Edward2 is different from Edward. One thing that I can easily see is the support for eager evaluation (i.e. no need to wait until the completion of computation graph). What are the other key changes in the high level?  * line 245: we are use ===> we are using    