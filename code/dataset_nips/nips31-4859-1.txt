This paper proposes an algorithm for program synthesis in an incremental way. There are three steps to it: 1) searching for program solutions, 2) expandind the dsl by discovering useful reusable components, 3) training a neural network that primes the program solution search in 1). The interesting part of the contribution is the focus on roughly mimicking the way humans refactor, recompose and reuse when coding.  Strengths - the problem presented is interesting, and the scc algorithm is novel. the theoretical framework is sound, and approximations made are reasonable and useful - the paper presents a good evaluation framework on three different tasks and through the ablation analysis that clearly shows the contributions of each part of the model to the final results - the results are impressive - excellent performance on all three tasks, both accuracy-wise and time-wise   Weaknesses - this is quite a dense paper and it packs a lot of information - the paper could benefit from a comparison to a well known systems such as flashfill, where the dsl is fixed  Questions: - 125-126 the probability of a variable occurring in a program. could you provide an example here? - equation 3 - is this the counting norm? if so, can you provide a quick rationale why it is used - 167 - can you explicitly say what AIC is and/or cite it? - 181-183 - how is this unification done? - 200 - was this manually created? - what was the recognition model validated on?  Other: - figure 4 position is weird - figure 4 bottom left and right are not clear  update: reading the author response I'm firmly standing by my score - I want to see this paper accepted. The authors addressed all the questions I had, and all the other reviewers' concerns. The paper will still stay densely packed with info, and I hope the authors will fix the issues of the appendix as otherwise it will be difficult to follow the main body of the paper without it.