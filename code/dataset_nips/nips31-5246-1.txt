       This paper discusses transfer learning for program synthesis from input-output examples. The paper presents a new language to define the space of       differentiable functional programs, which combines differentiable neural network layers, as well as non-differentiable functional constructors,       i.e., maps and folds. Each program in the language can be trained as a neural network, which transforms inputs into outputs. The paper also       presents two heuristics for sampling programs from the space. Some evaluation results are presented.        In general, the main issue is that it is unclear what is the main contribution of this work. The language is new, though simple. The sampling        algorithm can actually be seen as an architecture search algorithm, but not discussed in depth. The hardness of handling branching is not discussed        in this work, since not needed; as a result, training a program, which is essentially a neural network architecture, is pretty standard.       So far, nothing very surprising.        I was surprised by the claim that the approach can handle shortest path algorithms. However, the results are presented only in the supplemental       materials. By digging into the results, the RMSE can be as large as 5.51, which almost means a failure for a small graph.        I would suggest the authors better organize the materials for the next version. In particular, I observe that the authors are facing the challenge       from the space requirements, but the paper can be better organized as follows. (1) Fig 3 can be replaced with an end-to-end example       to show the interesting aspects of the proposed algorithm. Right now, an end-to-end example is missing, which makes understanding this work very       hard. (2) The shortest-path example, which is the most compelling application of this work, should be presented in full in the main body. Other       less important and sometime tedious details can be deferred to the appendix. (3) The introduction should have a short paragraph summarizing a list       of the most important contributions.        Some minor ones: for the syntax in Fig 1, Atom is a TT, which is a ADT, which is a F, which is in \tau. Thus, it can be defined        \tau = ADT | \tau->\tau        and removing F without hurting the correctness. This will also saves you a line.       