The authors propose to modify stochastic gradient methods such as SVRG to reuse computed stochastic gradients. They made two assumptions: A1. When perturbing parameters with radius r, the fraction of stochastic gradients need to recompute grows sublinearly w.r.t. r. A2. Estimating a safe radius r w.r.t. some sample in A1 is as hard as computing its stochastic gradient. With these assumptions, the authors showed theoretically that gradient descent can be modified to achieve better gradient complexity (i.e. w.r.t. number of gradient computation). These assumptions are then verified empirically on a revenue maximization problem on real-world dataset. For experiments, the authors showed that SVRG as well as its SCSG variant can be modified to achieve better gradient complexity.  Strengths: The paper is well written. The theoretical analysis is sound and the idea is novel to me. If the assumptions hold, this approach can be generalized to other problems.  Weaknesses: 1. Generalizability. In general, I think the authors need to show how this approach can work on more problems. For example, it looks to me that for most deep net problem A2 is not true. Also, some empirical verification of assumption A1 alone on other problems would be useful to convince me why this approach can generalize.   2. Stability evaluation/analysis is missing. How sensitive is the performance to the lingering radius (i.e. theta or equivalently delta(x, i))? Could the authors give some theoretical analysis or some empirical evaluation?  3. Memory consumption. For many real-world applications, the stochastic gradient methods mentioned in this paper are not acceptable due to huge memory consumption. Could the authors explain how to generalize this approach to other methods, e.g. stochastic gradient descent with fixed batch size? I would expect the growing number of lingering stochastic gradients to be an issue.  Some Typos: L532: difference --> different L540: report report --> report  ------- Response to Author's feedback: 1. For A1, I agree that if we have explicit written f_i(x) then we can compute radius in a easy way. My original concern is when the function is too complicated that the radius do not have a easy close form, then can we at least empirically evaluate the radius. I guess if the authors want to focus outside DL then this might not be a big issue anymore.  2. I think my concern is no longer a issue if the function can be written explicitly.  3. Originally, I was imagining a deep net setting, where storing O(nd) is not acceptable. And I have concerns about the overhead of computing this on the fly. But I guess it's not a problem whenever SVRG is acceptable.