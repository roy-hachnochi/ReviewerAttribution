The paper proposes a tracing and rewriting system called Autoconj that automatically exploits conjugacy of exponential distributions in probabilistic programs. The tool operates on ordinary Python programs without using a domain-specific language. The authors provide a brief description of how the rewriting systems works and demonstrate how to use it on several examples.  The paper is well written and the contribution is potentially significant. As noted by the authors, conjugate relationships were previously exploited within probabilistic programming, but only within a context of domain-specific languages. This made it very difficult to incorporate such tools within more generic PPLs, since that would require compiling the probabilistic program into the required DSL, applying the simplification, and compiling back. Since Autoconj operates directly on Python programs, it should be possible to easily deploy it within another Python-based PPL. I should point out, however, that this claim was not demonstrated in the paper. The submission would be very strong if it included an example of using Autoconj within an existing PPL that doesn't currently exploit conjugacy.  I am not an expert on exponential families so perhaps I'm missing something obvious but I found section 2 a little confusing. Specifically, are claims 2.1 and 2.2 original contributions or are they known results? If the former I would expect them to be proven, at least in the appendix, even if such proofs are considered straightforward. If the latter I would expect a specific pointer to existing literature.  My main complaint about the paper is that the rewriter is only described at a high level in section 3. The description gives me some idea how it works but nowhere near enough for me to implement such a tool. A table of rewrite rules or even a small calculus on which the rewrites can be formally defined would go a long way here. The authors claim their rewriting algorithms always terminates producing a result in a canonical form but I have no way of verifying that statement if the rules aren't actually presented.  The examples are well chosen and useful for understanding how Autoconj can be applied in practice, in particular showing that it can indeed be applied to normal Python programs. The experiment with factor analysis demonstrates that exploiting conjugacy can be very useful for approximate inference. The second experiment shows that running code on GPU and be much faster than on CPU and the authors point out that the machinery needed to implement Autoconj can be very easily extended to convert NumPy operations to Tensorflow getting extra performance for free.  Overall I believe the Autoconj tool can be very useful but I'm not sure if the paper itself provides that much value. It feels a bit like reading the extended abstract, where the underlying methods are mentioned but not discussed in depth. I don't think there is enough detail in there for others to implement a similar system. I still recommend acceptance though, since for better or worse this level of description of software systems seems to be more or less standard in the community.