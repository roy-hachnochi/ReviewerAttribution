Originality: This work studies a problem variant related to variants studied in the past. It depends on some of these past results (e.g. Myerson’s algorithm). On the other hand, the problem seems a bit artificial; is there a practical use case for needing all three? For what problem is recourse necessary over the more standard Steiner tree problem?  Quality: This work defends its algorithms with both theoretical proofs as well as empirical tests. In a sense, the experiments just confirm the obvious, since they’re comparing a tailored algorithm with the most obvious first attempts, but I can’t really fault the authors for doing the legwork. The work feels a bit incomplete in that it doesn’t really explain why the bounds on this algorithm are “right” for the problem.  Clarity: I found the paper well-written.  Significance: This is a nice starting point for future work to further develop by finding better algorithms or better lower bounds.  Rebuttal: I have read the author's rebuttal, but I'm not sure the problem they study is completely aligned with the applications they suggest (clustering webpages, search queries, news articles, social networks, etc.). In these high scale applications, where super-efficient data structures become necessary, I would not expect the need for a data structure maintaining clusters to reflect the precise state of the world up to the last update, since there then there would be race conditions between updates and queries. In other words, it should be permissible to batch a bunch of updates. The results in this work appear optimized for the "a query appears after every update" ratio, and I wonder if better results are possible with batching. For example, is constant recourse per update necessary, or just constant recourse per batch? These questions could be answered by a better experimental section. Would this algorithm be good enough/what resources would it need to process one day's worth of tweets in a day? Also, the twitter data set seems to be the only data set even coming close to suggested applications.