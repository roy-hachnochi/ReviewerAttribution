This paper studies the computational complexity of learning a single ReLU with respect to Gaussian examples. Since ReLUs are now the standard choice of nonlinearity in deep neural networks, the computational complexity of learning them is clearly of interest. Of course, the computational complexity of learning a ReLU may depend substantially on the specific setting assumed; it is interesting to understand the range of such assumptions and their implications for complexity. This paper studies the following setting: given independent samples (x_1,y_1), ... , (x_n,y_n) where x is spherical Gaussian in d dimensions and y \in R is arbitrary, find a ReLU function f_w(x) = max(0, w \cdot x) for some vector w with minimal mean squared error \sum (y_i - f(x_i))^2. (This is agnostic learning since the y's are arbitrary.)  The main results are as follows:  1) There is no algorithm to learn a single ReLU with respect to Gaussian examples to additive error \epsilon in time d^{o(log 1/\epsilon)} unless $k$-sparse parities with noise can be learned in time d^{o(k)}  2) If opt = min_{w} (mean squared error of f) then (with normalization such that opt \in [0,1]) there is an algorithm which agnostically learns a ReLU to error opt^{2/3} + \epsilon in time poly(d,1/\epsilon).  The proof of (1) goes via Hermite analysis (i.e. harmonic/Fourier analysis in Gaussian space) together with a nice ``coordinate deletion'' trick to use a ReLU learner to identify the relevant coordinates in a k-sparse parity with noise. The proof of (2) uses a reduction to a recent algorithm for agnostically learning halfspaces.  An important feature of (1) is the contrast it presents to recent results showing that gradient descent can learn ReLUs in polynomial time *when the labels y_i are exactly equal to some ReLU* -- i.e. in the realizable setting.  I am not an expert in all the prior work, this paper appears to clear both the novelty and importance bars for acceptance to NeurIPS. The paper is reasonably well-written.  I would prefer if the authors were somewhat more formal in their theorem statements in the introduction, and gave a more detailed SQ lower bound (as it is there is some lack of rigor to support the rather bold claim in the introduction about gradient descent). It would also be good to point out that the difference (as I understand it) between the running times ruled out by the lower bound and what the approximation algorithm achieves is d^(log(1/epsilon)) versus poly(d,1/epsilon) -- in many contexts these two running times are not too dissimilar, at least as compared to, say, d^(1/epsilon). (Is there an obvious d^(1/epsilon) time algorithm, for instance?)  UPDATE: I have read the author responses. I agree it is important to rule out any algorithm with fixed polynomial running time, and that the lower bound is quite interesting. I think it would be nice point out in the final paper that the complexity of the problem remains fairly wide open -- e.g. it might be possible to give a either a lower bound or algorithm for time $d^(1/\epsilon)$. I continue to feel that the paper should be accepted.