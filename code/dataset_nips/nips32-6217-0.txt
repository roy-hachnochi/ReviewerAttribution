(Continuing my answer to "contributions"... I ran out of space)  STRONG POINTS/CONTRIBUTIONS  1) The false positive rates and false negative rates observed when using AutoPerf are impressively low.  2) The paper is very well written and easy to follow.  3) The evaluation uses a wide variety of significant, real-world codes.  NEGATIVE POINTS  1) The paper lacks a lot of technical depth and novelty… autoencoders for anomaly detection are widely used, and the problem domain (detecting performance bugs) has been studied previously as well.  2) It strikes me that a version of AutoPerf that was production quality could not ignore commit logs, as the authors seem to have done. Knowing what was changed in the code between P_i and P_i+1 could be very, very helpful.  3) The idea of using k-means clustering can speed things a bit, but it is perhaps not the most natural way to do this. Instead, why not just conditions the identity of the function?  4) The evaluation focuses on finding synthetic anomies, rather than real, known performance bugs.  DETAILED COMMENTS  One comment is that I’m not sure it makes a lot of sense to train separate autoencoders for each function (or group of functions, if you are doing the k-means thing). Likely, there are going to be certain characteristics of the distributions that are shares across all functions, and I worry that you are wasting a lot of compute power by relearning everything. One simple idea would be to learn a single autoencoder, but you would condition the encoder and decoder on the function. That is, you have a separate input to both your encoder and decoder networks that is the identity of the function, but you are conditioning on this (you are not trying to reconstruct the function label), This may allow you to get rid of the multiple autoencoders entirely, and use only one of them.  It is interesting that there is this implicit assumption that any changes in performance between P_i and P_i+1 are bad… that they represent depredations in performance. Clearly, this is not the case. Someone can fix a performance bug across versions. Currently, you are likely to flag such a fix as a bug. Is there an easy way to differentiate between good and bad changes? Can this be done without having training data?   One big concern that I have about this paper is technical depth and novelty. When it comes right down to it, the authors are simply proposing to use a state-of-the-art approach to anomaly detection to the problem of finding changes in performance across multiple versions of a program. It appears that using anomaly detection to fund performance problems is not new or novel, and I know enough about anomaly detection to know that sing an autoencoder + reconstruction error to do anomaly detection is a fairly standard thing to do nowadays. So what we are left with is a solidly-written paper that applies a standard anomaly detection methodology to a problem that has been studied previously. For this reason, it is tough to get too excited about the paper.  It would be nice to know how many functions are in each of the tested codes. I just assumed that a lot of functions were tested for performance bugs, but according to Figure 5, this may not be the case. In fact, I’m surprised that Boost, for example has k = 7 before clustering. Does this mean that Boost has 7 functions?!?! This is very surprising, since Boost is huge. Obviously, there is something that I am missing here, or else maybe the authors have radically down-sampled the codes for evaluation. Regardless, this needs to be explained.  It would be good to have more detailed about the anomalies introduced. Note using val anomalies weakens the experimental evaluation, but not having detailed on exactly how the anomies were introduced weakens it even more.