The authors have developed a tool that is well documented, open sourced, and version controlled. The first two thirds of the article read like a user's manual, which is appropriate in a technical article, but not in its entirety. The neatly organized code snippets and commentary will help a programmer who is considering using the API. However, to encourage them to use it, the Use case section must be expanded with figures and performance metrics. I have added more details in the comments below. Major comments: Title - " platform-agnostic storage and understanding... " - The word "understanding" seems either ambiguous or inappropriate since StatsDB is just the facilitator for interpreting/visualizing the run metrics. Consider a title like " StatsDB: platform-agnostic storage schema and API for interpreting next-generation sequencing run metrics " Page 4, Database design - The relationship between the analysis table and the auxiliary views is unclear. For example, the analysis table stores a unique ID and timestamp of when an analysis run was performed. But the latest_run view mentions that an analysis can be run more than once. Please clarify. Page 10, Use case - Add a figure with a flowchart showing the TGAC pipeline that is explained in the text. It is critical to show how StatsDB plugs into a standard analysis pipeline. For the source code, an LGPL license might be more appropriate than GPL because StatsDB is an API, rather than a standalone tool in a workflow. LGPL would also allow parsers/consumers for manufacturer-supplied metrics. Minor comments: Page 3, Database installation - The code snippets show file names with accidental whitespace. Specifically: statsdb_schema.sql, stored_procedures.sql, and parse_fastqc.pl Page 3, Introduction - " With this data heterogeneity and abundance, comes a.. ." - missing comma. Page 5, Database design - How would you store metrics that depend on genomic positions or ranges? e.g targeted sequencing coverage. If tables per_position_value and per_partition_value stored values based on genomic positions or ranges, it would also depend on which reference sequence build (e.g. NCBI36, GRCh37) was in use for that analysis. Would we define that build as a value_type ? And in the stored procedures used by the APIs, how can we handle a mix of different reference builds used across runs? Page 7, Java API - accidental whitespace in filename fastqc_data.txt 