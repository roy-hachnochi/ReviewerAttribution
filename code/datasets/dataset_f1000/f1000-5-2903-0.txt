The article describes the author’s open-source toolkit, “Phylommand,” which was designed to perform basic operations on phylogenetic trees from the command line. Phylommand was designed with an emphasis on portability/compatibility (by using standard libraries that enable easy cross-platform compilation), efficiency (by writing in C++ as opposed to higher-level scripting languages), and usability (by providing clean and extensive documentation, both online as well as in the tools themselves). The article provides a nice summary of what the tools in Phylommand do. However, the reader is referred to the manuals to learn about the exact features implemented in the toolkit; in the paper, only general descriptions of the functions included in each tool are included. Moreover, some of the operations (e.g. mid-point rooting) require non-trivial algorithms, and how the tool approaches these steps is unclear. Appropriately, the authors make multiple references to their main competitor toolkit, namely Newick Utilities. There is one study comparing the two tools in terms of runtime, but this comparison is limited to a single task (rooting trees). Further, even though Newick Utilities is (to our knowledge) the only command line alternative, there are solutions to many of these problems outside of Newick Utilities in scripting languages (e.g. Dendropy for Python and APE in R). It can be argued that a command line tool has a different type of utility and is perhaps more usable. Nevertheless, since scripting languages are also relatively easy to use, comparisons to these platforms in terms of usability and speed would be informative. At a minimum, a mention would be needed. The code is in C++ using standard libraries, making it simple to compile and run. We were able to compile it out-of-the-box with the “make” command on a Mac OS X laptop as well as on a CentOS and an Ubuntu server. Regarding the algorithmic aspects of the toolkit, we have concerns about efficiency, mainly driven by our examination of the code related to the midpoint rooting (note that other potentially non-trivial functions may also have issues, but we only explored midpoint rooting). As mentioned before, the algorithmic details are not provided in the paper. After digging a bit into the code, we were able to understand the midpoint rooting function (tree.cpp lines 528 through 577), and it appears a heuristic is performed: the algorithm starts with the initial rooting of the tree, and it then iteratively shifts the root to the left or right child to minimize the imbalance between the maximum distance to a left descendant leaf vs. a right descendant leaf. Once the imbalance does not improve beyond a hardcoded threshold (average of the maximum left tip distance and the maximum right tip distance, divided by 10,000), the iterative search terminates and the left and right branches of the “optimal” root are adjusted. The main problem is the following. This “heuristic” solution is designed for a problem that has a trivial exact linear-time solution. Thus, the heuristic is unnecessary. With one bottom-up traversal and one top-down traversal of the tree, one can find the exact correct midpoint root in linear time. A linear time implementation of the midpoint rooting algorithm can be found here: https://github.com/uym2/MinVar-Rooting (runs in under a minute for 200,000 leaves). The midpoint rooting code raises some questions. First, why is the number 10,000 hardcoded here? There is no restriction in the unit of distance used by trees that can be passed to this tool, so what if the input tree used a unit that resulted in huge integers for branch lengths? It seems as though hard-coding 10,000 could potentially cause issues. Second, this heuristic solution is quadratic-time in the worst case, but as mentioned earlier, an exact solution can be trivially obtained in linear time. Third, when given a tree rooted at a leaf, the algorithm fails (and the tool segfaults); why? This is a valid edge case. Below is the tree we tested: ((B:2000000000,(C:3000000000,D:4000000000)E:5000000000)F:1000000000)A; We did not investigate any other functions but given our reservations about the correctness of the midpoint rooting function, we have reservations about the correctness of other non-trivial functions performed by Phylommand. Explanations of the algorithms behind the non-trivial functions seem essential to the article. 