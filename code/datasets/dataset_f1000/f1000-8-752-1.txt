In this paper Su et al present BiocPkgTools, an R package that provides programmatic access to metadata about software in the Bioconductor project. The package is available from Bioconductor and the source code can be easily viewed on Github. The metadata it can access includes download numbers, package 'health' status, topic categories, and software dependencies. Since the software forms at least as large a part of this publication as the article, I have tried to review both. Paper: The paper is succinct and to the point. In some instances there is an implied understanding of R package development and the Bioconductor build system. For example, in the code block presented to demonstrate the biocBuildReport function, the row names e.g. buildbin, checksrc etc are probably fairly meaningless to someone unfamiliar with Bioconductor's continuous integration platform. It's fair to say most interested readers will already be Bioconductor package developers, but a caption linking this back to the build system discussion in the introduction would add clarity. Similarly the biocViews concept is not full described, but forms a key part of one the packages main functions: biocExplore(). Expanding a little on how these terms are assigned to packages (i.e. mostly but not always by the package authors) might make it clearer to users why some values return unexpected results e.g. 'Bioinformatics' only shows me 15 packages presumably because most package authors see this as redundant, although 'Software' feels similarly obvious yet returns a huge number of packages as this is assigned by Bioconductor itself. The motivation behind providing programmatic access to build reports and download statistics is presented in the text. However, it would be nice for the authors to expand upon what they feel the use cases for the package dependency graphs may be. They look cool, but based on the paper content it's not immediately obvious to me where they might be used. The discussion highlights the fact that download metrics etc are gaining traction as a measure factored into funding decisions, and one thing that springs to mind is that a similar point can be made visually for software infrastructure that has many downstream dependents. My efforts to create a `subgraphByDegree()` with degree greater than one (to view a larger software stack) creates a graph to large to render, so an example of how to visualise this (i.e. show all downstream dependsOnMe packages in a tree) would be a great addition to either the paper or the package vignette. Minor points: I recommend providing a link to the BiocPkgTools landing page after the sentence "Installation instructions are detailed on the package website." Indicate that the code to produce Figure 3 can be found in the package vignette (or include it as supplementary material here). Since it is quite a bit more than a one-liner to produce Figure 3 I think it would be beneficial to point readers to the code. Perhaps I am mistaken, but I can find no mention in the paper or package of what the colours represent in the bubble plots produced by biocExplore(). They definitely feel like they should mean something. I would consider rephrasing the sentence "This interactively visualises the relative number of downloads each package has under different biocViews". To me this reads like the plot is somehow visualising how relevant the package is to the selected view, when really it is just filtering the package list based on the biocView category. Typos (given in context, specific [word] highlighted): for all Bioconductor [pacakages] software [catergory] tags Bioconductor [sofware] usage bioc[b]uildReport (Table 1) Software: In general the software is well written with a comprehensive vignette providing more extensive examples than seen in the paper. However I did encounter a few issues when testing aspects of the package: The function firstInBioc() fails with 'Error in desc(Date) : could not find function "desc"'. Similarly, the function inducedSubgraphByPkgs() fails with 'Error in V(g2) - `*vtmp*` : could not find function "V-"' I think in both cases the relevant functions need to be added as imports in the NAMESPACE. These work in the package examples as additional libraries are loaded first. The manual page for subgraphByDegree() is slightly confusing. The argument pkg takes a vector of length one, but the description field reads like multiple packages can be supplied. Why is the function get_bioc_data() in snake_case, while all other functions are named with camelCase? I wonder if the function biocBuildEmail() should really be exported. This seems very specific to the Bioconductor core team, but is very similarly named to biocBuildReport() which is one of the primary data getters and will be widely used. Also, the 'Usage' section of the biocBuildEmail function references the function .getTemplatePath() which is not exported, perhaps reflecting the niche nature of this function. It's not clear to me what the difference is between an 'induced subgraph' and a 'regular subgraph' in the functions inducedSubgraphByPkgs() vs subgraphByDegree() and I couldn't find an explanation in the package documentation. Perhaps this is just a lack of knowledge about graphs on my part, but it's information I looked for based on the different function names. Are all of the packages listed in the Suggests field of the DESCRIPTION file used? I can't find mention of tm, SnowballC 