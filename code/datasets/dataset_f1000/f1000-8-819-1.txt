Mourao et al. describe a package for estimation of the rate at which stranding information in an RNA-seq sample might be wrong, thus leading to inaccurate quantification of anti-sense transcription, which they apply to their own data and the data of others. This is a fascinating and useful contribution to RNA-seq analysis. The software described should be useful to a range of scientists working the analysis of RNA biology from transcriptomics data. I will split my evaluation of this into two sections – the manuscript/science, and the software: Manuscript: The manuscript is generally well written and describes an interesting problem. I believe that the approach is generally sound. I have a few small issues that the authors might like to address: It is assumed that anti-sense spliced reads are spurious. However, one possibility is that anti-sense spliced reads arise by the action of RNA-dependent RNA-polymerases. The authors acknowledge this point, but state “only 8-30% of eukaryotic gene regions have significant length ORFs on their opposite strands, providing an upper limit on the potential impact of this method of transcript on the RNA complement within a cell”. I am unsure how the presence of an ORF on the anti-sense strand has an effect on the RNA complement of a cell. The authors should clarify this argument. An underlying assumption of the approach is that the ratio of spurious anti-sense reads to sense reads is consistent across the length of the transcript, and thus modelled by the reverse junction reads. This assumption is probably necessary and reasonable, but perhaps the authors might make it explicit. In regions where two annotated transcripts overlap, the authors truncate their antisense copies of these transcripts to only cover the region that is unique to the sense transcript in question. This is necessary to avoid double counting of reads. However, it does mean that the number of reads counted as antisense will be an underestimate. This becomes problematic because the full length transcript, not the truncated version is used when calculating how many spurious antisense reads are present (this is possible because this is calculated from spliced reads). Thus the correction factor will be overestimated compared to the counted number of antisense reads. This could be detected by finding genes where the correction factor is larger than the total number of antisense reads leading to a negative corrected value for the antisense count. Unfortunately the package truncates the corrected count at 0, so these counts are not evident in output from the package. The authors show that there is a large variation in the proportion of anti-sense reads that are spurious in three replicates of the same experimental condition. It would be useful to know if this variation is bigger or smaller than that between conditions. Variation within replicates reduces power to detect differential expression between conditions, but systematic variation between conditions might lead to false positive calls of differential expression. The authors might consider looking at the within condition and between condition variance of samples in the Graveley data set they have analysed. The authors introduce the concept of a “maximal transcript”. This is very similar to the concept of the superTranscript 1 the authors might like to acknowledge this and cite the relevant work. The authors note that for some genes there is more anti-sense expression than sense expression and suggest this might be a case of incorrect annotation. Do these genes tend to be spliced or single exon. If spliced, does the annotation carry the canonical splice sequence, its reverse complement, or some other sequence? Figure 5 is reproduced at a very low resolution, such that it is not possible to read all the text on the panel marked (Right). Software: The software is provided as an R package with a number of accompanying python modules and is available on GitHub. An archived version of the source code used to produce the figures in the paper is available on Zenodo. Dependencies are intended to be installed using a conda environment. The authors are to be commended on their good practice in this respect. However, I did have a number of issues in attempting to use the software: I could not install the conda environment from the provided environment file. Running the suggested commands gave the following error: Solving environment: failed ResolvePackageNotFound: - r-base==3.5.1=h4fe35fd_0 - libssh2==1.8.0=h5b517e9_2 - matplotlib==2.2.3=py27h8e2386c_0 To try and fix this problems I removed the pinning on the exact build, leaving only the pinning on version number. This returned the following error: Solving environment: failed UnsatisfiableError: The following specifications were found to be in conflict: - matplotlib=2.2.3 - sip=4.18.1 - tk=8.6.8 I was able to install by manually creating an environment using the dependencies listed in the readme, although using the pip install for rosa downgraded the pandas install from 0.24 to 0.19. The ability to install all dependencies as a conda environment is very useful to the average user, and the authors should consider either fixing the supplied env file, or (ideally) creating a proper rosa conda package, so that rosa and all its dependencies (both R and python) can be installed with conda install rosa. Once installed I found the documentation to be a little on the sparse side, and it times confusing. For example, the help for the `rosa` function states that the parameter “data” should be a list of dataframes with a particular list of columns. But the help for the “group” parameter says that it is a character vector specifying the replicates for each column in data. Thus it is unclear if replicates should be provided as a member of a list of data.frames, or as separate columns in one data.frame. There are required arguments for matrices of spike-in counts, as well as an argument to provide the positions of spike-ins in the “data” matrix. It is unclear whether spike-ins should be provided using only one or both of these mechanisms, or what to do if there is no spike-in data. The help states “This function was written with the intention of obtaining count and group parameters from an edgeR DGEList object d, via d$counts and d$samples$group.” But d$counts would not return a data.frame of the format specified in the help for the “data” argument. The manuscript doesn’t really mention TPMs, but the help for rosa states that TPMs are required to run the function. I believe it would not be clear to a less experienced user how to calculate a TPM for the anti-sense counts generated on the custom anti-sense annotation. Not help page is provided for either the `count_spliced` nor `make_annotation` functions. Nor is much in the way of documentation provided for the python scripts these functions call. The package has no associated vignette. I think it would be of great use to users, particularly less experienced ones, to provide a walk-through of the analysis of a dataset from start to finish, with a simplified example dataset. Overall, I think that this work is both novel, interesting, useful and basically sound. Before I can recommend approval, I would need to see minimally that the issues identified with installation and documentation have been dealt with. I would also be interested in the authors replies to my comments on the manuscript itself. 