The paper presents a novel deep network architecture termed DELPHI to automatically infer loop invariants for use in program verification. The architecture takes in as input source code which has (1) a number of assumption or assignment statements, (2) a loop with nested if-else statements with arithmetic operations and (3) a final assertion statement. The output of the architecture is a loop invariant in CNF which holds true at every iteration in the loop, and for which the assertion (3) is true after the loop ends execution. The architecture represents the source code AST using a graph-structured neural network, and treats it as a structured memory which it repeatedly accesses through attention operations. The generation of the CNF invariant is broken up into a sequential decision-making process where at each time the architecture predicts an output (op, T), where op is either && or || and T is a simple logical expression. The partial CNF invariant is re-encoded by a Tree LSTM after each action output, and the next step prediction is conditioned on this information. Due to the lack of available ground-truth labels, the entire system is trained using RL (the loop invariant is either validated or rejected by an automated theorem prover, Z3). The reinforcement signal is the binary success/failure returned by Z3 along with some shaping rewards, with some based on the types of counterexamples that are returned by Z3. The architecture is empirically validated on a set of 133 benchmark programs, and is compared against previous state-of-the-art solvers which span a variety of methods from stochastic search to decision-tree-based heuristics. Results show that DELPHI is highly competitive with the state-of-the-art and, despite not beating every previous method, requires fewer queries to Z3. Additionally, DELPHI is shown to demonstrate the ability to transfer knowledge, pre-training the architecture on a set of related programs provides a significant improvement in performance when learning is continued on a “test” set. The paper’s writing is clear and the description of the architecture and the methods used to train it is well explained.  Additionally, the motivation behind DELPHI as perhaps imitating the human process behind loop invariant generation provides intuition behind the architectural choices.  The paper presents a step towards automatic program verification using deep neural networks. DELPHI’s performance is highly competitive with the current state-of-the-art, and this is especially promising given that (1) DELPHI demonstrates transfer if pretrained on a set of programs and (2) the currently available loop invariant datasets are very small (on the order of 133 programs). Given that deep networks often work better the more data you have, this suggests that potentially DELPHI’s performance could improve even further if more data was available. The architecture is clearly defined, and detailed explanations of the parts of the network are provided. The use of attention over the program AST encoded as a graph-neural-network was interesting. An ablation experiment suggested that each component of the model provided some benefit, and that not one part was solely responsible for the success of the model.   A potential weakness is that the metric used for comparison between baselines, number of queries to the Z3 theorem prover, is not necessarily a practical performance measure. It is not clear how the methods compare to each other in terms of absolute wall clock time or some measure of compute. It is understandable that DELPHI could do worse in these measures (with the consideration that future work could potentially narrow the gap), but I think it would still be interesting to see what the current difference is. Additionally, some architectural choices were made without necessarily testing whether simpler baselines worked better (e.g. would attention over the linearized program encoded by an LSTM work just as well as the program encoded by the graph-structured neural network?). Finally, the related work is only a short section in the appendix, which I believe can be expanded on and should be pushed into the main paper.  In summary, I believe this work presents an interesting step towards deep program verification. The experiments are relatively comprehensive, the architecture is interesting and intuitive, and the results demonstrate not only the feasibility but the state-of-the-art competitiveness of combining deep architectures and RL in the context of verification. It also provides some evidence that deep architectures are conducive to transfer, meaning that their performance will likely improve with the size of the datasets available, in contrast to the purely search-based methods.  