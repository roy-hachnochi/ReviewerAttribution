## After rebuttal  The authors well addressed my questions. I think that even inliers do not have a unified learning target in AE-based methods is the key reason why AE-based methods fails. It will be nice to empirically verify this. For example, the authors can do a similar experiment as that in Figure 2. Anyway, I believe this paper has its contribution to the community. I will raise my score to 7.  ----------------------------------------------------------------------  Strengths:  - I like the idea that we can create some high-level supervision from unlabeled data rather than just using the low-level pixel-level supervision like in the autoencoder. And surprisingly, the algorithms greatly improve the outlier detection performance compared to multiple AE-based methods.  Questions:  - The key point of this method is to create pseudo labels for the unlabeled data, which will augment the training data by default. When training the AE-based methods. Did the authors also used the same kind of data augmentation? What is the latent dimension of the AE? In my opinion, to fairly compare the proposed algorithm and the AE-based methods, there should also be the same data augmentation for the AE-based methods and the latent dimension for the AE should be smaller than K, which is the number of different operations. This is because the capacity of the network is very important when using AE to detect the outlier. Suppose the network capacity is infinite and the latent dimension is equal to the input dimension, then the model will perfectly remember all the data and has no ability to detect the outliers. So using data augmentation and choosing a small latent dimension might help improve the outlier detection performance since it will make the network has little extra capacity to fit the outliers. Of course the proposed method used the extra high-level information, but I am curious about whether it is the pseudo label that is working or it is just the data augmentation / limited output dimension that is helping more.  - What is the point of all the derivations from line 155 to line 180? With the randomly initialized network, isn't it obvious that the inlier will dominate the gradients since it has more samples? These derivations are trying to make things complicated but no extra intuition/information is given. I know the authors are trying to make things more rigorous. But in the derivation, strong and impractical assumptions are needed and the conclusion is trivial. What I care more about is that as the learning procedure goes on, whether the gradients from the inlier or the outlier will dominate. My intuition would be that in the early stage the inlier will dominate, as the authors suggested. However, as the training procedure goes on, each inlier sample will have very small gradients. If the network capacity is really huge, it will also try to fit the outlier. Otherwise the gradient of each inlier sample will be much smaller than that of each outlier sample, though the gradient of ALL the inlier samples may still be larger than that of all the outlier samples. Either a rigorous derivation or an empirical validation will be much interesting than the trivial derivations from line 155 to 180.  - The analysis between line 181 and 197 is kind of the same thing as the analysis between line 155 to 180. Suppose you have two vectors g_{in} and g_{out}. The magnitude of g_{in} is much larger than g_{out}. Let g_{sum} = g_{in} + g_{out}. Of course the angle between g_{in} and g_{sum} is much smaller and thus g_{sum} will have a larger projection in the direction of g_{in} than g_{out}. I am glad that the authors validate this empirically in Figure 2, which verifies the intuition.   - It seems the choice of the operation set is also important. As the authors mentioned, a digit "8" will still be an "8" when applying a flip operation. The authors argued this will cause a misclassification. Though I agree with this, I think such cases will also harm the training. Ideally speaking, for a digit "8", it will give 0.5 probability to FLIP and 0.5 probability to NOT FLIP. This will make any "8" looks like an outlier based on this operation alone. Of course the model can still remedy this problem by using other operations. What I just argued is just an example where some kinds of operations may make things worse. A good way to check this is to train another model without the flip operator on digit "8" and see if the performance increases. It would also be nice to provide a general guidance about how to select the operations.  - How did the authors deal with the regions in the transformed image that has no correspondence in the original image? For example, if we try to shift the image 1 step in the left direction, then how did the authors deal with the right most column in the transformed image? If we just use zeros to fill that column, the network will easily distinguish this for both inlier and outlier samples without learning any high-level representations. 