Update after authors response: Thank you for the thorough responses to my questions. In light of these answers, I maintain that this paper should be accepted.  ====  =1 I suggest revising the following claim in the abstract: “We… provide preliminary experimental evidence that our algorithm may enjoy improved practical performance”  [L12-13] compared to the fastest practical algs, such as Sinkhorn. I suggest changing “improved practical performance” to “competitive practical performance”, as the experiments at best only appear to indicate this more modest claim, no?  There is of course the issue of whether to optimize parameters when comparing algs—for both the proposed alg as well as Sinkhorn. This issue is brought up in the paper. However, it should be pointed out that Sinkhorn has only one parameter (entropy), whereas the proposed alg has two parameters (entropy and stepsize). Moreover, Sinkhorn’s parameter is very intuitive and in practice it is very easy to choose a reasonable value for it, so this parameter optimization is not a problem in practice for Sinkhorn.   =2 The size of the experiments is extremely small, n=196. The authors write that they even downsampled from the original dataset which had n=784 (still very small) to speed up experiments. Sinkhorn easily scales to way larger sizes. So was this downsampling because the proposed alg does not scale well in n? Please include a plot demonstrating scalability in n, with n on the x-axis and runtime (for a fixed precision) on the y-axis.  =3 Many runtimes reported in the previous work section are not scale invariant and thus seem very suspicious. E.g. ||C||_max^0.5/eps and ||C||_max/\eps^2 in L83 and Table 1. For scale invariance, runtimes for eps additive approx to OT should have the same dependence on ||C||_max as on 1/eps. Am I missing something?  =4 Since there are exponentials in the proposed alg, please comment briefly on bit-complexity. In particular, is the bit-complexity only polylog in 1/eps, rather than poly in 1/eps? I ask since if the bit-complexity is e.g. 1/eps, then the n^2/eps runtime would really be n^2/eps^2, which is the same as Sinkhorn.  =5 The authors state several times [e.g. L104,L275] that they believe their proposed alg can be sped up by using similar kernel-approx techniques as in [ABRW18]. How? The way this was done in [ABRW18] was low-rank approx of the kernel matrix exp(-eta*C), but that kernel matrix doesn’t seem to be relevant for the proposed alg.  =6 I am confused why Appendix C exists. This is just re-proving a lemma from a previous paper, in the same way as originally done in that paper. Is there any difference? If not, this section should be deleted; just cite the original paper.   =7 L227,L248: the inequalities seem to be in opposite directions?  As a side comment, MNIST is perhaps not the best choice of dataset, since for OT between images, Sinkhorn iterations can be implemented exactly in \tilde{O}(n) time rather than n^2 using FFT. See e.g. Peyre-Cuturi’s book S4.3  Minor comments =L60: The use of entropic regularization for OT actually goes back half a century, see e.g. [Wilson, 1969, “The use of entropy maximising models…”] =L152: a minimizing argument =L153: there is some optimal x with Ax=b -> that all optimal x satisfy Ax=b =L187: Prox is missing r on top =L234: any -> all? =L251: n -> n^2 =References have many “??”  =References: missing some capitalization, e.g. Newton, Lagrangian, Sinkhorn, Wasserstein, etc =App B: Lemmas B.1, B.2, B.3 are copy-and-pastes of Lemmas 3.2,3.3,3.5, respectively. I suggest removing the lemma statements in the appendix to shorten the paper. If not, at least re-title the lemmas to have the same numbering as main text (3.2,3.3,3.5) to avoid confusing the reader